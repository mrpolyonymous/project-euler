package mrpolyonymous.problem2

import org.openjdk.jmh.annotations._

import scala.collection.mutable.ArrayBuffer

/**
  * Some benchmarking of Fibonacci sequence generation
  */
class Problem2 {

  @Benchmark
  def fixedList(): List[Int] = {
    val l = List(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55)
    l
  }

  @Benchmark
  def consList(): List[Int] = {
    val l = 0 :: 1 :: 1 :: 2 :: 3 :: 5 :: 8 :: 13 :: 21 :: 34 :: 55 :: List()
    l;
  }

  @Benchmark
  def fixedArray(): Array[Int] = {
    val l = Array(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55)
    l
  }

  @Benchmark
  def arrayBuffer(): ArrayBuffer[Int] = {
    val l = new ArrayBuffer[Int](16)
    l += 0
    l += 1
    l += 1
    l += 2
    l += 3
    l += 5
    l += 8
    l += 13
    l += 21
    l += 34
    l += 55
    l
  }

  // very slow, don't try with n > 35
  def recursiveFib(n:Int):Long = {
    if (n == 0) return 0L
    else if (n == 1) return 1L

    return recursiveFib(n-1) + recursiveFib(n-2)
  }

  @Benchmark
  def bmRecursiveFib(): Long = {
    recursiveFib(30)
  }

  // less slow
  def iterativeFibWithFor(n:Int):Long = {
    if (n == 0) return 0L
    else if (n <= 2) return 1L
    var fibN = 1L
    var fibN1 = 1L
    var fibN2 = 0L
    var tmp = 0L
    for (x <- 1 until n) {
      tmp = fibN
      fibN = fibN1 + fibN2
      fibN2 = fibN1
      fibN1 = fibN
    }

    return fibN
  }

  @Benchmark
  def bmIterativeFibWithFor(): Long = {
    iterativeFibWithFor(30)
  }

  def iterativeFibWithWhile(n:Int):Long = {
    if (n == 0) return 0L
    else if (n <= 2) return 1L
    var fibN = 1L
    var fibN1 = 1L
    var fibN2 = 0L
    var tmp = 0L
    var loopVariable = n - 1
    while (loopVariable > 0) {
      loopVariable -= 1
      tmp = fibN
      fibN = fibN1 + fibN2
      fibN2 = fibN1
      fibN1 = fibN
    }

    return fibN
  }

  @Benchmark
  def bmIterativeFibWithWhile(): Long = {
    iterativeFibWithWhile(30)
  }

  def tailRecursiveFib(n:Int): Long = {
    return tailRecursiveFibHelper(0, 1, n)
  }
  def tailRecursiveFibHelper(a:Long, b:Long, n:Int):Long = {
    if (n == 0) a
    else tailRecursiveFibHelper(b, a + b, n - 1)
  }

  @Benchmark
  def bmTailRecursiveFib(): Long = {
    tailRecursiveFib(30)
  }

  // Some benchmarks on generating a sequence of 30 Fibonacci numbers
  @Benchmark
  def sequenceWithStream(): List[Long] = {
    lazy val fibs: Stream[Long] = 0L #:: 1L #:: fibs.zip(fibs.tail).map { n => n._1 + n._2 } take (30)
    fibs.toList
  }

  // Some benchmarks on generating a sequence of 30 Fibonacci numbers
  @Benchmark
  def sequenceWithIteration(): List[Long] = {
    var n2 = 0L
    var n1 = 1L
    var tmp = 0L
    var fibs: List[Long] = n2 :: List()
    var x = 29
    while (x > 0) {
      x -= 1
      fibs = n1 :: fibs
      tmp = n1
      n1 = n1 + n2
      n2 = tmp
    }

    fibs.reverse
  }


}

/**
  * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
  **
  *1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
  **
  *By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
  */
object Problem2  {


  def main(args: Array[String]): Unit = {
    println("Sum of even Fibonacci numbers below 4M is")

    // Construct taken from the Stream documentation
    lazy val fibs: Stream[BigInt] = BigInt(0) #:: BigInt(1) #:: fibs.zip(fibs.tail).map { n => n._1 + n._2 }

    val answers: Stream[BigInt] = fibs take 10 filter {
      !_.testBit(0)
    }
    val longAnswer: Long = answers.foldLeft(0L)(_ + _.toLong)
    println(longAnswer)

    println("\n\nAnd now for some Fibonacci numbers")
    val fibCalculator = new Problem2
    (1 to 20) foreach { i =>
      println("Fibonacci number %2d is %d".format(i, fibCalculator.recursiveFib(i)))
    }

    (1 to 20) foreach { i =>
      println("Fibonacci number %2d is %d".format(i, fibCalculator.iterativeFibWithFor(i)))
    }

    (1 to 20) foreach { i =>
      println("Fibonacci number %2d is %d".format(i, fibCalculator.iterativeFibWithWhile(i)))
    }

    (1 to 20) foreach { i =>
      println("Fibonacci number %2d is %d".format(i, fibCalculator.tailRecursiveFib(i)))
    }

    println("From sequences")
    fibCalculator.sequenceWithIteration() foreach println
    fibCalculator.sequenceWithStream() foreach println
  }
}
